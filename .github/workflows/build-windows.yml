name: Build Windows Server 2019

on:
  push:
  pull_request:
    branches:
      - master
env:
  IS_GITHUB_SIGNING_ALLOWED: true
  IS_JENKINS_SIGNING_ALLOWED: true

jobs:
  build-windows:
    runs-on: windows-2019

    steps:
    - name: Install Qt
      uses: jurplel/install-qt-action@v3
      with:
        setup-python: 'false'
        version: '5.15.2'
        target: 'desktop'
        arch: 'win64_msvc2015_64'

    # Downgrading nuget is required as of 2021-04-23, as nuget 5.9.1.111 fails installing protobuf
    # https://github.com/actions/virtual-environments/issues/3240
    - name: Downgrade nuget
      uses: nuget/setup-nuget@v1
      with:
        nuget-version: '5.8.x'

    - name: Install Dependencies
      # choco install of version 1.9.3 produced a checksum error
      run: choco install doxygen.install --version=1.9.2

    - name: Uninstall Chocolatey
      run: move "$env:PROGRAMDATA\chocolatey" "$env:PROGRAMDATA\_chocolatey"

#    - name: Install Capâ€™n Proto
#      run: |
#        mkdir "${{ runner.workspace }}/capnp"
#        cd "${{ runner.workspace }}/capnp"
#        git clone https://github.com/sandstorm-io/capnproto.git
#        cd capnproto
#        git checkout release-0.9.0
#        cd c++
#        mkdir _build
#        cd _build
#        cmake .. -G "Visual Studio 16 2019" -A x64
#        cmake --build . --parallel --config Release
#        cmake --build . --target install --config Release

    - name: Checkout
      uses: actions/checkout@v3
      with:
        submodules:  'true'
        fetch-depth: 0

    - name: Download NPCAP
      run: |
        cd %GITHUB_WORKSPACE%
        powershell -Command "& 'build_win\download_npcap.ps1'"
      shell: cmd

    - name: Create Python virtualenv
      run: |
        mkdir "${{ runner.workspace }}\_build\complete\.venv\"

        # At the moment (2021-10-27) there is no official Python 3.10 lxml package available on pypi. Thus we use python 3.9.
        py -3.9 -m venv "${{ runner.workspace }}\.venv"
        CALL "${{ runner.workspace }}\.venv\Scripts\activate.bat"

        echo Upgrading pip
        python -m pip install --upgrade pip

        pip install wheel

        echo Installing python requirements
        pip install -r "%GITHUB_WORKSPACE%\requirements.txt"

      shell: cmd

    - name: CMake SDK
      run: |
        mkdir "${{ runner.workspace }}\_build\sdk\"
        cd "${{ runner.workspace }}/_build/sdk"

        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 ^
        -DHAS_HDF5=ON ^
        -DHAS_QT5=ON ^
        -DHAS_CURL=OFF ^
        -DHAS_CAPNPROTO=OFF ^
        -DHAS_FTXUI=ON ^
        -DBUILD_DOCS=OFF ^
        -DBUILD_APPS=OFF ^
        -DBUILD_SAMPLES=OFF ^
        -DBUILD_TIME=ON ^
        -DBUILD_PY_BINDING=OFF ^
        -DBUILD_CSHARP_BINDING=OFF ^
        -DBUILD_ECAL_TESTS=OFF ^
        -DECAL_LAYER_ICEORYX=OFF ^
        -DECAL_INCLUDE_PY_SAMPLES=OFF ^
        -DECAL_INSTALL_SAMPLE_SOURCES=OFF ^
        -DECAL_JOIN_MULTICAST_TWICE=OFF ^
        -DECAL_NPCAP_SUPPORT=ON ^
        -DECAL_THIRDPARTY_BUILD_CMAKE_FUNCTIONS=ON ^
        -DECAL_THIRDPARTY_BUILD_PROTOBUF=ON ^
        -DECAL_THIRDPARTY_BUILD_SPDLOG=ON ^
        -DECAL_THIRDPARTY_BUILD_TINYXML2=ON ^
        -DECAL_THIRDPARTY_BUILD_FINEFTP=OFF ^
        -DECAL_THIRDPARTY_BUILD_CURL=OFF ^
        -DECAL_THIRDPARTY_BUILD_GTEST=OFF ^
        -DECAL_THIRDPARTY_BUILD_HDF5=ON ^
        -DECAL_THIRDPARTY_BUILD_RECYCLE=ON ^
        -DECAL_THIRDPARTY_BUILD_TCP_PUBSUB=ON ^
        -DECAL_THIRDPARTY_BUILD_QWT=OFF ^
        -DECAL_THIRDPARTY_BUILD_YAML-CPP=OFF ^
        -DECAL_THIRDPARTY_BUILD_UDPCAP=ON ^
        -DBUILD_SHARED_LIBS=OFF ^
        -DCMAKE_PREFIX_PATH="%ProgramFiles%/Cap'n Proto/lib/cmake/CapnProto" ^
        -DCMAKE_BUILD_TYPE=Debug ^
        -DCPACK_PACK_WITH_INNOSETUP=OFF
      shell: cmd

    - name: CMake Complete
      run: |
        CALL "${{ runner.workspace }}\.venv\Scripts\activate.bat"
        cd "${{ runner.workspace }}/_build/complete"
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 ^
        -DHAS_HDF5=ON ^
        -DHAS_QT5=ON ^
        -DHAS_CURL=ON ^
        -DHAS_CAPNPROTO=OFF ^
        -DHAS_FTXUI=ON ^
        -DBUILD_DOCS=ON ^
        -DBUILD_APPS=ON ^
        -DBUILD_SAMPLES=ON ^
        -DBUILD_TIME=ON ^
        -DBUILD_PY_BINDING=ON ^
        -DBUILD_CSHARP_BINDING=ON ^
        -DBUILD_ECAL_TESTS=ON ^
        -DECAL_LAYER_ICEORYX=OFF ^
        -DECAL_INCLUDE_PY_SAMPLES=OFF ^
        -DECAL_INSTALL_SAMPLE_SOURCES=ON ^
        -DECAL_JOIN_MULTICAST_TWICE=OFF ^
        -DECAL_NPCAP_SUPPORT=ON ^
        -DECAL_THIRDPARTY_BUILD_CMAKE_FUNCTIONS=ON ^
        -DECAL_THIRDPARTY_BUILD_PROTOBUF=ON ^
        -DECAL_THIRDPARTY_BUILD_SPDLOG=ON ^
        -DECAL_THIRDPARTY_BUILD_TINYXML2=ON ^
        -DECAL_THIRDPARTY_BUILD_FINEFTP=ON ^
        -DECAL_THIRDPARTY_BUILD_CURL=ON ^
        -DECAL_THIRDPARTY_BUILD_GTEST=ON ^
        -DECAL_THIRDPARTY_BUILD_HDF5=ON ^
        -DECAL_THIRDPARTY_BUILD_RECYCLE=ON ^
        -DECAL_THIRDPARTY_BUILD_TCP_PUBSUB=ON ^
        -DECAL_THIRDPARTY_BUILD_QWT=ON ^
        -DECAL_THIRDPARTY_BUILD_YAML-CPP=ON ^
        -DECAL_THIRDPARTY_BUILD_UDPCAP=ON ^
        -DBUILD_SHARED_LIBS=OFF ^
        -DCMAKE_PREFIX_PATH="%ProgramFiles%/Cap'n Proto/lib/cmake/CapnProto" ^
        -DCMAKE_BUILD_TYPE=Release ^
        -DCPACK_PACK_WITH_INNOSETUP=ON
        mkdir "%ALLUSERSPROFILE%\eCAL"
        copy "%GITHUB_WORKSPACE%\ecal\core\cfg\ecal.ini" "%ALLUSERSPROFILE%\eCAL"
      shell: cmd

    - name: Build SDK
      run: cmake --build . --config Debug
      working-directory: ${{ runner.workspace }}/_build/sdk

    - name: Build Release
      run: cmake --build . --config Release
      working-directory: ${{ runner.workspace }}/_build/complete

    # Create Python.
    # The strang-looking double-cmake is an ugly workaround to force CMake to
    # re-find Python, after we have changed the venv from the outside. The
    # alternative would be to clean everything, which would cause an unnecessary
    # rebuild of eCAL and HDF5 for each python Version.
    - name: Build Python 3.11 Wheel
      run: |
        mkdir ".venv_311"
        py -3.11 -m venv ".venv_311"
        CALL ".venv_311\Scripts\activate.bat"
        pip install wheel
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=FIRST
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=ONLY
        cmake --build . --target create_python_wheel --config Release
      shell: cmd
      working-directory: ${{ runner.workspace }}/_build/complete

    - name: Build Python 3.10 Wheel
      run: |
        mkdir ".venv_310"
        py -3.10 -m venv ".venv_310"
        CALL ".venv_310\Scripts\activate.bat"
        pip install wheel
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=FIRST
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=ONLY
        cmake --build . --target create_python_wheel --config Release
      shell: cmd
      working-directory: ${{ runner.workspace }}/_build/complete

    - name: Build Python 3.9 Wheel
      run: |
        mkdir ".venv_39"
        py -3.9 -m venv ".venv_39"
        CALL ".venv_39\Scripts\activate.bat"
        pip install wheel
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=FIRST
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=ONLY
        cmake --build . --target create_python_wheel --config Release
      shell: cmd
      working-directory: ${{ runner.workspace }}/_build/complete

    - name: Build Python 3.8 Wheel
      run: |
        mkdir ".venv_38"
        py -3.8 -m venv ".venv_38"
        CALL ".venv_38\Scripts\activate.bat"
        pip install wheel
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=FIRST
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=ONLY
        cmake --build . --target create_python_wheel --config Release
      shell: cmd
      working-directory: ${{ runner.workspace }}/_build/complete

    - name: Build Python 3.7 Wheel
      run: |
        mkdir ".venv_37"
        py -3.7 -m venv ".venv_37"
        CALL ".venv_37\Scripts\activate.bat"
        pip install wheel
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=FIRST
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=ONLY
        cmake --build . --target create_python_wheel --config Release
      shell: cmd
      working-directory: ${{ runner.workspace }}/_build/complete

    - name: Build Python 3.6 Wheel
      run: |
        mkdir ".venv_36"
        py -3.6 -m venv ".venv_36"
        CALL ".venv_36\Scripts\activate.bat"
        pip install wheel
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=FIRST
        cmake %GITHUB_WORKSPACE% -G "Visual Studio 16 2019" -A x64 -T v140 -DPython_FIND_VIRTUALENV=ONLY
        cmake --build . --target create_python_wheel --config Release
      shell: cmd
      working-directory: ${{ runner.workspace }}/_build/complete

#    - name: Build Documentation C
#      run: cmake --build . --target documentation_c
#      working-directory: ${{ runner.workspace }}/_build
#
#    - name: Build Documentation C++
#      run: cmake --build . --target documentation_cpp
#      working-directory: ${{ runner.workspace }}/_build

    - name: Run Tests
      run: ctest -C Release -V
      working-directory: ${{ runner.workspace }}/_build/complete

    - name: Pack SDK
      run: cpack -C Debug
      working-directory: ${{ runner.workspace }}/_build/sdk

    - name: Pack complete setup
      run: cpack -C Release
      working-directory: ${{ runner.workspace }}/_build/complete

    - name: Detect certificate
      id: cert
      if: env.IS_GITHUB_SIGNING_ALLOWED == 'true'
      run: |
        if [[ -n "${CERT_BODY}" \
           && -n "${CERT_PSWD}" \
           && -n "${CERT_ALGO}" \
           && -n "${CERT_HASH}" ]]
        then
          echo "ATTENTION: a certificate is available"
          echo "is_cert_available=true" >> $GITHUB_ENV
        else
          echo "WARNING: a certificate is not available"
          echo "is_cert_available=false" >> $GITHUB_ENV
        fi
      shell: bash
      env:
        CERT_BODY: ${{ secrets.CERT_BODY }}
        CERT_PSWD: ${{ secrets.CERT_PSWD }}
        CERT_ALGO: ${{ secrets.CERT_ALGO }}
        CERT_HASH: ${{ secrets.CERT_HASH }}

    # https://github.com/OrhanKupusoglu/code-sign-action
    - name: Sign the installer
      if: env.IS_GITHUB_SIGNING_ALLOWED == 'true' && env.is_cert_available == 'true'
      uses: OrhanKupusoglu/code-sign-action@v5.5.1
      with:
        cert_body: ${{ secrets.CERT_BODY }}
        cert_pswd: ${{ secrets.CERT_PSWD }}
        cert_algo: ${{ secrets.CERT_ALGO }}
        cert_hash: ${{ secrets.CERT_HASH }}
        folder: ${{ runner.workspace }}/_build/complete/_deploy
        debug: false

    - name: Upload Windows setup
      uses: actions/upload-artifact@v3
      with:
        name: windows-setup
        path: ${{ runner.workspace }}/_build/complete/_deploy/*.exe

    - name: Upload Python Wheels
      uses: actions/upload-artifact@v3
      with:
        name: windows-python-wheels
        path: ${{ runner.workspace }}/_build/complete/_deploy/*.whl

    - name: Sign the installer on Eclipse CI
      if: env.IS_JENKINS_SIGNING_ALLOWED == 'true' && env.JENKINS_TOKEN != ''
      run: |
        export LC_CTYPE=en_US.utf8

        ARTIFACT_EXE=$(ls *.exe)
        ARTIFACT_NAME="${ARTIFACT_EXE}"
        ARTIFACT_NAME_OLD="${ARTIFACT_NAME}.old"
        ARTIFACT_NAME_NEW="${ARTIFACT_NAME}"
        JENKINS_JOB='gh_auto'
        TOKEN="${JENKINS_TOKEN}"
        JENKINS_LAST_BUILD_URL="https://ci.eclipse.org/ecal/job/${JENKINS_JOB}/lastBuild/buildNumber"
        JENKINS_TRIGGER_URL="https://ci.eclipse.org/ecal/job/${JENKINS_JOB}/build?token=${TOKEN}"
        JENKINS_STATUS_URL="https://ci.eclipse.org/ecal/job/${JENKINS_JOB}/lastBuild/api/json"
        JENKINS_DOWNLOAD_URL="https://ci.eclipse.org/ecal/job/${JENKINS_JOB}/lastSuccessfulBuild/artifact/${ARTIFACT_NAME}"
        WAIT_FOR_JENKINS_SEC=5
        STATUS_JSON=status.json
        NEW_BUILD=0

        mv "${ARTIFACT_NAME}" "${ARTIFACT_NAME_OLD}"

        printf -- "-- get last build number\n"
        RESPONSES=($(curl -s -S -L -w " %{response_code}" "${JENKINS_LAST_BUILD_URL}"))
        LAST_BUILD="${RESPONSES[0]}"
        RESPONSE_CODE="${RESPONSES[1]}"
        ((NEW_BUILD = LAST_BUILD + 1))
        printf -- "    ++ last build - HTTP status code: %s\n" "${RESPONSE_CODE}" 
        printf -- "    ++ last build#: ${LAST_BUILD}, new build#: ${NEW_BUILD}\n" 
        if [[ ${RESPONSE_CODE} -ge 200 && ${RESPONSE_CODE} -lt 300 ]]
        then
          true
        else
          printf -- "    ** last build number failure\n"
          exit 1
        fi

        printf -- "-- trigger a new build\n"
        RESPONSE_CODE=$(curl -s -S -L -w "%{response_code}" "${JENKINS_TRIGGER_URL}")
        printf -- "    ++ trigger - HTTP status code: %s\n" "${RESPONSE_CODE}" 
        if [[ ${RESPONSE_CODE} -ge 200 && ${RESPONSE_CODE} -lt 300 ]]
        then
          true
        else
          printf -- "    ** trigger failure\n"
          exit 1
        fi

        printf -- "-- check build status\n"
        while true
        do
          RESPONSE_CODE=$(curl -s -S -w "%{response_code}" -o "${STATUS_JSON}" "${JENKINS_STATUS_URL}")
          printf -- "    ++ status check - HTTP status code: %s\n" "${RESPONSE_CODE}" 
          if [[ ${RESPONSE_CODE} -ge 200 && ${RESPONSE_CODE} -lt 300 ]]
          then
            true
          else
            printf -- "    ** status failure\n"
            exit 1
          fi

          NUMBER=$(grep -oP "(?<=\"number\":)(\w*)(?=,)" -- "${STATUS_JSON}")
          if [[ ${NUMBER} -eq ${NEW_BUILD} ]]
          then
            BUILDING=$(grep -oP "(?<=\"building\":)(\w*)(?=,)" -- "${STATUS_JSON}")
            if [[ "${BUILDING}" == 'true' ]]
            then
                printf -- "    ++ building ..., wait for ${WAIT_FOR_JENKINS_SEC}s\n"
                sleep ${WAIT_FOR_JENKINS_SEC}
            else
                RESULT=$(grep -oP '(?<=\"result\":\")(\w*)(?=\",)' -- "${STATUS_JSON}")
                if [[ "${RESULT}" == 'SUCCESS' ]]
                then
                    printf -- "    ++ build success\n"
                    break
                else
                    printf -- "    ** build failure\n"
                    exit 1        
                fi
            fi
          else
            printf -- "    ++ ... pending, wait for ${WAIT_FOR_JENKINS_SEC}s\n"
            sleep ${WAIT_FOR_JENKINS_SEC}
          fi
        done

        printf -- "-- download the newly-signed Windows installer\n"
        RESPONSE_CODE=$(curl -s -S -w "%{response_code}" -o "${ARTIFACT_NAME_NEW}" "${JENKINS_DOWNLOAD_URL}")
        printf -- "    ++ download - HTTP status code: %s\n" "${RESPONSE_CODE}" 
        if [[ ${RESPONSE_CODE} -ge 200 && ${RESPONSE_CODE} -lt 300 ]]
        then
          echo "is_download_available=true" >> $GITHUB_ENV
          printf -- "    ++ downloaded: '${ARTIFACT_NAME_NEW}'\n"
        else
          echo "is_download_available=false" >> $GITHUB_ENV
          printf -- "    ** download failure\n"
          exit 1
        fi
      shell: bash
      working-directory: ${{ runner.workspace }}/_build/complete/_deploy
      env:
        JENKINS_TOKEN: ${{ secrets.JENKINS_TOKEN_GH_AUTO }}
        
    - name: Upload Windows setup signed on Eclipse CI
      if: env.IS_JENKINS_SIGNING_ALLOWED == 'true' && env.is_download_available == 'true'
      uses: actions/upload-artifact@v3
      with:
        name: windows-setup-eclipse
        path: ${{ runner.workspace }}/_build/complete/_deploy/*.exe
